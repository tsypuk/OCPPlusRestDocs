---1 chapter1
Q: What is the result of the following code?
1: public class Employee {
2:      public int employeeId;
3:      public String firstName, lastName;
4:      public int yearStarted;
5:      @Override public int hashCode() {
6:          return employeeId;
7:      }
8:      public boolean equals(Employee e) {
9:          return this.employeeId == e.employeeId;
10:     }
11:     public static void main(String[] args) {
12:         Employee one = new Employee();
13:         one.employeeId = 101;
14:         Employee two = new Employee();
15:         two.employeeId = 101;
16:         if (one.equals(two)) System.out.println("Success");
17:         else System.out.println("Failure");
18: }}
A.+ Success
B.- Failure
C.- The hashCode() method fails to compile.
D.- The equals() method fails to compile.
E.- Another line of code fails to compile.
F.- A runtime exception is thrown.
Y: A. Based on the equals() method in the code, objects are equal if they have the same employeeId. The hashCode() method correctly overrides the one from Object. The equals() method is an overload of the one from Object and not an override. It would be better to pass Object since an override would be better to use here. It is odd to override hashCode() and not equals().
---2 chapter1
Q: What is the result of compiling the following class?
1:   public class Book {
2:      private int ISBN;
3:      private String title, author; private int pageCount;
4:      public int hashCode() {
5:          return ISBN;
6:      }
7:      @Override public boolean equals(Object obj) {
8:          if ( !(obj instanceof Book)) {
9:          return false;
10:         }
11:     Book other = (Book) obj;
12:     return this.ISBN == other.ISBN;
13:     }
14:   // imagine getters and setters are here }
A.+ The code compiles.
B.- The code does not compile because hashCode() is incorrect.
C.- The code does not compile because equals() does not override the parent method correctly.
D.- The code does not compile because equals() tries to refer to a private field.
E.- The code does not compile because the ClassCastException is not handled or
declared.
F.- The code does not compile for another reason.
Y: A. hashCode() is correct and perfectly reasonable given that equals() also checks that field. ClassCastException is a runtime exception and therefore does not need to be han- dled or declared. The override in equals() is correct. It is common for equals() to refer to a private instance variable. This is legal because it is within the same class, even if it is referring to a different object of the same class.
---3 chapter1
Q: What is the result of the following code?
1:  String s1 = "Canada";
2:  String s2 = new String(s1);
3:  if(s1 == s2) System.out.println("s1 == s2");
4:  if(s1.equals(s2)) System.out.println("s1.equals(s2)");
A.- There is no output.
B.- s1 == s2
C.+ s1.equals(s2)
D.- Both B and C.
E.- The code does not compile.
F.- The code throws a runtime exception.
Y: C. s1 points to the string pool. s2 points to an object on the heap, since it is created at runtime. == checks for reference equality. These are different references, making B incorrect. String overrides equals() so the actual values are the same, making C correct. And yes, this question could have appeared on the OCA. Remember that the OCP is cumulative. A question may appear to be about one thing and actually be about a simpler concept.
---4 chapter1
Q: What is true about the following code? You may assume city and mascot are never null.
1:  public class BaseballTeam {
2:      private String city, mascot;
3:      private int numberOfPlayers;
4:      public boolean equals(Object obj) {
5:          if ( !(obj instanceof BaseballTeam))
6:              return false;
7:          BaseballTeam other = (BaseballTeam) obj;
8:          return (city.equals(other.city) && mascot.equals(other.mascot));
9:  }
10:     public int hashCode() {
11:         return numberOfPlayers;
12:     }
13: //  imagine getters and setters are here
14: }
A.- The class does not compile.
B.- The class compiles but has an improper equals() method.
C.+ The class compiles but has an improper hashCode() method.
D.- The class compiles and has proper equals() and hashCode() methods.
Y: C. The equals() method is correct. You are allowed to use any business logic that you want in determining equality. The hashCode() method is not correct. It violates the rule that two objects that return true for equals() must return the same hashCode(). It is also a bad idea for the hash code to contain values that could change.
---5 chapter1
Q: Which of the following statements are true, assuming a and b are String objects? (Choose all that apply.)
A.+ If a.equals(b) is true, a.hashCode() == b.hashCode() is always true.
B.- If a.equals(b) is true, a.hashCode() == b.hashCode() is sometimes but not always true.
C.- If a.equals(b) is false, a.hashCode() == b.hashCode() can never be true.
D.+ If a.equals(b) is false, a.hashCode() == b.hashCode() can sometimes be true.
Y: A, D. The relevant rule is that two objects that return true for equals() objects must return the same hash code. Therefore A is correct and B is incorrect. Two objects with the same hash code may or may not be equal. This makes C incorrect and D correct. The fact that two objects are not equal does not guarantee or preclude them from sharing a hash code. Remember that hashCode() tells you which bucket to look in and equals() tells you whether you have found an exact match.
---6 chapter1
Q: What is the result of the following code?
1:   public class FlavorsEnum {
2:      enum Flavors {
3:         VANILLA, CHOCOLATE, STRAWBERRY
4:      }
5:      public static void main(String[] args) {
6:          System.out.println(Flavors.CHOCOLATE.ordinal());
7:      }
8:  }
A.- 0
B.+ 1
C.- 9
D.- CHOCOLATE
E.- The code does not compile due to a missing semicolon.
F.- The code does not compile for a different reason.
Y: B. The ordinal() method of an enum returns its corresponding int value. Like arrays, enums are zero based. Remember that the index of an enum may change when you recompile the code and should not be used for comparison.
---7 chapter1
Q: What is the result of the following code? (Choose all that apply.)
1:  public class IceCream {
2:      enum Flavors {
3:          VANILLA, CHOCOLATE, STRAWBERRY
4:      }
5:      public static void main(String[] args) {
6:          Flavors f = Flavors.STRAWBERRY;
7:          switch (f) {
8:              case 0: System.out.println("vanilla");
9:              case 1: System.out.println("chocolate");
10:             case 2: System.out.println("strawberry");
11:                 break;
12:             default: System.out.println("missing flavor");
13:  }}}
A.- vanilla
B.- chocolate
C.- strawberry
D.- missing flavor
E.+ The code does not compile.
F.- An exception is thrown.
Y: E. A case statement on an enum data type must be the unqualified name of an enumeration constant. For example, case VANILLA would be valid. You cannot use the ordinal equiva- lents. Therefore, the code does not compile.
---8 chapter1
Q: What is the result of the following code?
1:  public class Outer {
2:      private int x = 5;
3:      protected class Inner {
4:          public static int x = 10;
5:          public void go() { System.out.println(x); }
6:      }
7:      public static void main(String[] args) {
8:          Outer out = new Outer();
9:          Outer.Inner in = out.new Inner();
10:         in.go();
11: }}
A.- The output is 5.
B.- The output is 10.
C.+ Line 4 generates a compiler error.
D.- Line 8 generates a compiler error.
E.- Line 9 generates a compiler error.
F.- An exception is thrown.
Y: C. Inner is a member inner class. Inner classes are not allowed to contain static methods or static variables. Only nested static classes are permitted to contain statics.
---9 chapter1
Q: What is the result of the following code?
1:  public class Outer {
2:      private int x = 24;
3:      public int getX() {
4:          String message = "x is ";
5:          class Inner {
6:              private int x = Outer.this.x;
7:              public void printX() {
8:                  System.out.println(message + x);
9:              }
10:         }
11:         Inner in = new Inner();
12:         in.printX();
13:         return x;
14:     }
15:     public static void main(String[] args) {
16:         new Outer().getX();
17: }}
A.- x is 0.
B.+ x is 24.
C.- Line 6 generates a compiler error.
D.- Line 8 generates a compiler error.
E.- Line 11 generates a compiler error.
F.- An exception is thrown.
Y: B. Outer.this.x is the correct way to refer to x in the Outer class. In Java 7, the answer would have been D because you used to have to declare variables as final to use them in a local inner class. In Java 8, this requirement was dropped and the variables only need to be effectively final, which means that the code would still compile if final were added.
---10 chapter1
Q: The following code appears in a file named Book.java. What is the result of compiling the source file ?
1:  public class Book {
2:      private int pageNumber;
3:      private class BookReader {
4:          public int getPage() {
5:              return pageNumber;
6:  }}}
A.- The code compiles successfully, and one bytecode file is generated: Book.class.
B.- The code compiles successfully, and two bytecode files are generated: Book.class and BookReader.class.
C.+ The code compiles successfully, and two bytecode files are generated: Book.class and Book$BookReader.class.
D.- A compiler error occurs on line 3.
E.- A compiler error occurs on line 5.
Y: C. The code compiles fine. A member inner class is allowed to be private, and it is allowed to refer to instance variables from the outer class. Two .class files are generated. Book.class matches the name of the outer class. The inner class does not compile to BookReader.class. That would introduce the possibility of a naming conflict. Book$BookReader.class is correct because it shows the scope of the class is limited to Book. You don’t need to know that $ is the syntax, but you do need to know the number of classes and that BookReader is not a top-level class.
---11 chapter1
Q:  Which of the following statements can be inserted to make FootballGame compile?
1:  package my.sports;
2:  public class Football {
3:      public static final int TEAM_SIZE = 11;
4:  }
1:  package my.apps;
2:  // INSERT CODE HERE
3:  public class FootballGame {
4:      public int getTeamSize() { return TEAM_SIZE; }
5:  }
A.- import my.sports.Football;
B.- import static my.sports.*;
C.- import static my.sports.Football;
D.+ import static my.sports.Football.*;
E.- static import my.sports.*;
F.- static import my.sports.Football;
G.- static import my.sports.Football.*;
Y: D. FootballGame is trying to refer to a static variable in another class. It needs a static import to do so. The correct syntax is import static and not static import. B is incorrect because * does not import classes in a package. C is incorrect because it does not refer to a static member.
---12 chapter1
Q: What is the result of the following code?
1:  public class Browsers {
2:      static class Browser {
3:          public void go() {
4:              System.out.println("Inside Browser");
5:          }
6:      }
7:      static class Firefox extends Browser {
8:          public void go() {
9:              System.out.println("Inside Firefox");
10:         }
11:     }
12:     static class IE extends Browser {
13:         @Override public void go() {
14:             System.out.println("Inside IE");
15:         }
16:     }
17:     public static void main(String[] args) {
18:         Browser b = new Firefox();
19:         IE e = (IE) b;
20:         e.go();
21:     }
22: }
A.- Inside Browser
B.- Inside Firefox
C.- Inside IE
D.- The code does not compile.
E.+ A runtime exception is thrown.
Y: E. The main method tries to cast a Firefox instance to IE. Since IE is not a subclass of Firefox, this throws a ClassCastException.
---13 chapter1
Q: Which is a true statement about the following code?
1:  public class IsItFurry {
2:      static interface Mammal { }
3:      static class Furry implements Mammal { }
4:      static class Chipmunk extends Furry { }
5:      public static void main(String[] args) {
6:          Chipmunk c = new Chipmunk();
7:          Mammal m = c;
8:          Furry f = c;
9:          int result = 0;
10:         if (c instanceof Mammal) result += 1;
11:         if (c instanceof Furry) result += 2;
12:         if (null instanceof Chipmunk) result += 4;
13:         System.out.println(result);
14:    }
15: }
A.- The output is 0.
B.+ The output is 3.
C.- The output is 7.
D.- c instanceof Mammal does not compile.
E.- c instanceof Furry does not compile.
F.- null instanceof Chipmunk does not compile.
Y: B. c is an instance of Chipmunk. It is an instance of any superclasses or interfaces it imple- ments. In this case, those are Furry, Mammal, and Object. null is not an instance of any type. Therefore, the first two if statements execute and result is 3.
---14 chapter1
Q: Which is a true statement about the following code? (Choose all that apply.)
1:  import java.util. *;
2:  public class IsItFurry {
3:      static class Chipmunk { }
4:      public static void main(String[] args) {
5:          Chipmunk c = new Chipmunk();
6:          ArrayList <Chipmunk> l = new ArrayList<>();
7:          Runnable r = new Thread();
8:          int result = 0;
9:          if (c instanceof Chipmunk) result += 1;
10:         if (l instanceof Chipmunk) result += 2;
11:         if (r instanceof Chipmunk) result += 4;
12:         System.out.println(result);
13:     }
14: }
A.- The code compiles, and the output is 0.
B.- The code compiles, and the output is 3.
C.- The code compiles, and the output is 7.
D.- c instanceof Chipmunk does not compile.
E.+ l instanceof Chipmunk does not compile.
F.- r instanceof Chipmunk does not compile.
Y: E. Code involving instanceof does not compile when there is no way for it to evaluate true. D not only compiles but it is always true. E does not compile because ArrayList is a concrete class that does not extend Chipmunk. F does compile because Runnable is an interface. In theory, someone could subclass Chipmunk and have the subclass implement Runnable.
---15 chapter1
Q: Which of the following statements are true about the equals() method? (Choose all that apply.)
A.- If equals(null) is called, the method should throw an exception.
B.+ If equals(null) is called, the method should return false.
C.- If equals(null) is called, the method should return true.
D.- If equals() is passed the wrong type, the method should throw an exception.
E.+ If equals() is passed the wrong type, the method should return false.
F.- If equals() is passed the wrong type, the method should return true.
Y: B, E. equals() should return false when the object it passed in is not equal to the cur- rent object. This includes null and incorrect types. An equals() method should have a null check and an instanceof check.
---16 chapter1
Q: Which of the following can be inserted in main?
1:  public class Outer {
2:      class Inner { }
3:          public static void main(String[] args) {
4:          // INSERT CODE HERE
5:          }
6:  }
A.- Inner in = new Inner();
B.- Inner in = Outer.new Inner();
C.- Outer.Inner in = new Outer.Inner();
D.- Outer.Inner in = new Outer().Inner();
E.+ Outer.Inner in = new Outer().new Inner();
F.- Outer.Inner in = Outer.new Inner();
Y: E. This is a member inner class. It needs to be created using an instance of the outer class. The syntax looks weird, but it creates an object of the outer class and then an object of the inner class from it.
---17 chapter1
Q: What is the result of the following code? (Choose all that apply.)
1:  public enum AnimalClasses {
2:      MAMMAL(true), FISH(Boolean.FALSE), BIRD(false),
3:      REPTILE(false), AMPHIBIAN(false), INVERTEBRATE(false)
4:      boolean hasHair;
5:      public AnimalClasses(boolean hasHair) {
6:          this.hasHair = hasHair;
7:      }
8:      public boolean hasHair() {
9:          return hasHair;
10:     }
11:     public void giveWig() {
12:         hasHair = true;
13:     }
14: }
A.- Compiler error on line 2.
B.+ Compiler error on line 3.
C.+ Compiler error on line 5.
D.- Compiler error on line 8.
E.- Compiler error on line 12.
F.- Compiler error on another line.
G.- The code compiles successfully.
Y: B, C. Enums are required to have a semicolon after the list of values if there is anything else in the enum. Don’t worry; you won’t be expected to track down missing semicolons on the whole exam—only on enum questions. Enums are not allowed to have a public constructor.
---18 chapter1
Q: What is the result of the following code? (Choose all that apply.)
1:  public class Swimmer {
2:      enum AnimalClasses {
3:          MAMMAL, FISH {
4:              public boolean hasFins() {
5:                  return true;
6:              }
7:          },
8:          BIRD, REPTILE, AMPHIBIAN, INVERTEBRATE;
9:      public abstract boolean hasFins();
10:     }
11:     public static void main(String[] args) {
12:         System.out.println(AnimalClasses.FISH);
13:         System.out.println(AnimalClasses.FISH.ordinal());
14:         System.out.println(AnimalClasses.FISH.hasFins());
15:         System.out.println(AnimalClasses.BIRD.hasFins());
16:     }
17: }
A.- fish
B.- FISH
C.- 0
D.- 1
E.- false
F.- true
G.+ The code does not compile.
Y: G. This question appears to be about enums but is really about abstract methods. Just as an abstract superclass requires concrete subclasses to have an implementation, abstract enum methods require each enum type to implement the method.
---19 chapter1
Q: Which of the following can be inserted to override the superclass method? (Choose all that apply.)
1:  public class LearnToWalk {
2:      public void toddle() {}
3:      class BabyRhino extends LearnToWalk {
4:          // INSERT CODE HERE
5:      }
6:  }
A.+ public void toddle() {}
B.- public void Toddle() {}
C.+ public final void toddle() {}
D.- public static void toddle() {}
E.- public void toddle() throws Exception {}
F.- public void toddle(boolean fall) {}
Y: A, C. An override must have the same method signature. A and C both do. F is an overload because it has a different parameter list. E does not compile because it throws a checked exception not declared in the superclass. D compiles but is not an override because it is static. B has a different method name, so it is not even an overload.
---20 chapter1
Q: What is the result of the following code?
1:  public class FourLegged {
2:      String walk = "walk,";
3:      static class BabyRhino extends FourLegged {
4:          String walk = "toddle,";
5:      }
5:      public static void main(String[] args) {
6:          FourLegged f = new BabyRhino();
7:          BabyRhino b = new BabyRhino();
8:          System.out.println(f.walk);
9:          System.out.println(b.walk);
10:     }
11: }
A.- toddle,toddle,
B.- toddle,walk,
C.+ walk,toddle,
D.- walk,walk,
E.- The code does not compile.
F.- A runtime exception is thrown.
Y: C. Both objects are BabyRhino objects. Virtual method invocation says that the subclass method gets called at runtime rather than the type in the variable reference. However, we are not calling methods here. We are referring to instance variables. With instance vari- ables, the reference type does matter.
---21 chapter1
Q: Which of the following could be inserted to fill in the blank? (Choose all that apply.)
1:  public interface Otter {
2:      default void play() { }
3:  }
4:  class RiverOtter implements Otter {
5:      _____________________________
6:  }
A.+ @Override public boolean equals(Object o) { return false; }
B.- @Override public boolean equals(Otter o) { return false; }
C.+ @Override public int hashCode() { return 42; }
D.- @Override public long hashCode() { return 42; }
E.+ @Override public void play() { }
F.- @Override void play() { }
Y: A, C, E. Remember that @Override means that we are implementing a method from a superclass or interface. The Object class declares methods with the signatures in Options A and C. Granted, it is a poor implementation of equals(), but it does compile. Option E is also correct because the method is declared in Otter. Option F is incorrect because meth- ods from an interface are always public. Option B is incorrect because the parameter type does not match the one in Object. Option D is incorrect because the return type does not match the one in Object.
---1 chapter2
Q: Which of the following statements about design principles and design patterns are true? (Choose all that apply.)
A.- A design principle is focused on solving a specific commonly occurring problem.
B.- Design principles and design patterns are the same thing.
C.+ Design principles are often applied throughout an application, whereas design patterns are applied to solve specific problems.
D.- Design patterns can only be applied to static classes.
E.+ Design principles and design patterns tend to produce code that is easier to maintain and easier for other developers to read.
Y: C, E. Option A is incorrect as a design pattern is focused on solving a specific commonly occurring problem. Option B is also incorrect, as design principles and design patterns are different, despite both promoting better code development. Option D is incorrect as design patterns may be applied to static or non-static classes alike. Options C and E are cor- rect statements about design principles and design patterns.
---2 chapter2
Q: What is the result of the following code?
1:  public interface CanClimb {
2:      public abstract void climb();
3:  }
4:  public interface CanClimbTrees extends CanClimb {}
5:  public abstract class Chipmunk implements CanClimbTrees {
6:      public abstract void chew(); }
7:      public class EasternChipmunk extends Chipmunk {
8:          public void chew() {
9:              System.out.println("Eastern Chipmunk is Chewing"); }
10:         }
A.- It compiles and runs without issue.
B.- The code will not compile because of line 2.
C.- The code will not compile because of line 4.
D.- The code will not compile because of line 5.
E.+ The code will not compile because of line 8.
F.- It compiles but throws an exception at runtime.
Y: E. The code does not compile because EasternChipmunk inherits the abstract method climb() but does not implement it, therefore the correct answer is E. B, C, and D are incorrect as they compile for various reasons. Line 2 compiles, as non-static and non- default interface methods are assumed to have the abstract modifier. Line 4 compiles without issue as an interface can extend another interface. Line 5 compiles without issue as an abstract class can implement an interface without implementing any of the abstract methods. F is incorrect, as Line 8 does not compile.
---3 chapter2
Q: Which of the following are valid functional interfaces? (Choose all that apply.)
1:  public interface Climb {
2:      public int climb();
3:  }
4:  public abstract class Swim {
5:      public abstract Object swim(double speed, int duration);
6:  }
7:  public interface ArcticMountainClimb extends MountainClimb {
8:      public default int getSpeed();
9:  }
10: public interface MountainClimb extends Climb {}
A.+ Climb
B.- Swim
C.- ArcticMountainClimb
D.+ MountainClimb
E.- None of these are valid functional interfaces.
Y: A, D. A is correct as Climb defines an interface with exactly one abstract method. B is incorrect, as abstract classes are not functional interfaces despite having a single abstract method. While functional interfaces may have any number of default methods, Arctic- MountainClimb will not compile due to the default method getSpeed() missing an implementation body, so C is incorrect. D is correct, as the interface MountainClimb has exactly one abstract method defined in Climb. Finally, E is incorrect because A and D are correct.
---4 chapter2
Q: Which of the following are valid lambda expressions? (Choose all that apply.)
A.+ () -> ""
B.- x,y -> x+y
C.- (Coyote y) -> return 0;
D.+ (Camel c) -> {return;}
E.- Wolf w -> 39
F.- () ->
G.- (Animal z, m) -> a
Y: A, D. The first lambda expression is valid, taking no arguments and returning the empty string, so A is correct. B is incorrect, as more than one parameter requires parentheses (). C is incorrect, as brackets {} are required when using return. D is correct, as the expres- sion takes one Camel input and returns void. E is incorrect, as parentheses are required when using the data type Wolf. F is incorrect, as it has no right-side expression. Finally, G is incorrect, as specifying the data type for one parameter in a lambda expression requires you to specify the data type for all parameters in the expression. In this case, z has a data type and m does not, therefore the expression is invalid.
---5 chapter2
Q: What are some of the properties of using the singleton pattern? (Choose all that apply.)
A.- Singleton object can be replaced with encapsulated setter method.
B.+ Requires constructor of singleton class to be private.
C.- Singleton object must be named instance.
D.- Singleton object may be private or protected.
E.+ Ensures that there is only one instance of an object in memory.
F.+ Requires a public static method to retrieve the instance of the singleton.
Y: B, E, F. A is incorrect, as any method that changes the singleton breaks the singleton pattern. B is correct, as the constructor of the singleton class must be private, else other classes would be able to instantiate it, breaking the singleton pattern. C is incorrect, as the name of the object itself, as well as the method to retrieve the singleton, is not defined in the pattern. D is incorrect, as the object must be marked private. If it was marked protected, it would not be properly encapsulated and other classes would have access to it. E is correct, as the purpose of a singleton is to ensure that all threads share the same instance of the object in memory. F is correct, as a public static method is required for all threads to access the same singleton.
---6 chapter2
Q: What is the result of the following class?
1:  import java.util.function.*;
2:  public class Panda {
3:      int age;
4:      public static void main(String[] args) {
5:          Panda p1 = new Panda();
6:          p1.age = 1;
7:          check(p1, p -> p.age < 5); // h1
8:      }
9:      private static void check(Panda panda, Predicate<Panda> pred) { // h2
10:         String result = pred.test(panda) ? "match": "not match"; // h3
11:         System.out.print(result);
12:     }
13: }
A.+ match
B.- not match
C.- Compiler error on line h1.
D.- Compiler error on line h2.
E.- Compile error on line h3.
F.- A runtime exception is thrown.
Y: A. This code compiles and runs without issue so C, D, E, and F are incorrect. Line h1 cre- ates a lambda expression that checks if the age is less than 5. Since there is only one param- eter and it does not specify a type, the parentheses around the type parameter are optional. Line h2 uses the Predicate interface, which declares a test() method. Since test() returns true on the expression, match is output and A is correct.
---7 chapter2
Q: What changes need to be made to make the following immutable object pattern correct? (Choose all that apply.)
1:  import java.util.List;
2:  public class Seal {
3:      String name;
4:      private final List<Seal> friends;
5:      public Seal(String name, List<Seal> friends) {
6:          this.name = name;
7:          this.friends = friends;
8:      }
9:      public String getName() { return name; }
10:     public List<Seal> getFriends() { return friends; }
11: }
A.- None; the immutable object pattern is properly implemented.
B.- Have Seal implement the Immutable interface.
C.+ Mark name final and private.
D.- Add setters for name and List<Seal> friends.
E.+ Replace the getFriends() method with methods that do not give the caller direct access to the List<Seal> friends.
F.- Change the type of List<Seal> to List<Object>.
G.+ Make a copy of the List<Seal> friends in the constructor.
H.+ Mark the Seal class final.
Y: C, E, G, H. A is incorrect, as there are definitely some problems with the immutable objects implementation. B is incorrect, as there is no such thing as the Immutable inter- face defined in the Java API. C is correct, as all instance variables should be private and final to prevent them from being changed by a caller. D is incorrect, as adding settings is the opposite of what you do with the immutable object pattern. E is correct, since List<Seal> is mutable, all direct access should be removed. F is incorrect, as this has nothing to do with immutability. G is correct, as we need to copy the mutable List<Seal> to prevent the caller of the constructor from maintaining access to a mutable structure within our class. H is also correct, as it prevents the methods of the class from being overridden.
---8 chapter2
Q: Which of the following are true of interfaces? (Choose all that apply.)
A.- They can extend other classes.
B.- They cannot be extended.
C.+ They enable classes to have multiple inheritance.
D.- They can only contain abstract methods.
E.- They can be declared final.
F.+ All members of an interface are public.
Y: C, F. A and B are both incorrect as interfaces can extend other interfaces, although not classes. C is correct since a class may implement multiple interfaces. D is incorrect as inter- faces have static and default methods, as well as static final variables. E is incor- rect as interfaces are assumed to be abstract, and abstract and final can never be used together. F is correct as interface methods and variables are each assumed public.
---9 chapter2
Q: What changes need to be made to make the following singleton pattern correct? (Choose all that apply.)
1:  public class CheetahManager {
2:      public static CheetahManager cheetahManager;
3:      private CheetahManager() {}
4:      public static CheetahManager getCheetahManager() {
5:          if(cheetahManager == null) {
6:              cheetahManager = new CheetahManager();
7:          }
8:          return cheetahManager;
9:      }
10: }
A.- None; the singleton pattern is properly implemented.
B.- Rename cheetahManager to instance.
C.- Rename getCheetahManager() to getInstance().
D.+ Change the access modifier of cheetahManager from public to private.
E.- Mark cheetahManager final.
F.+ Add synchronized to getCheetahManager().
Y: D, F. A is incorrect, as there are definitely some problems with the singleton implementa- tion. B and C are incorrect, as naming of the instance variable and access method are not required as part of the pattern. The public modifier on the cheetahManager instance means that any class can access or even replace the instance, which breaks the singleton pattern; hence D is required to fix the implementation. E is incorrect, as marking the instance final would prevent lazy instantiation and as the code would not compile. F is also required, since without this step two threads could create two distinct instances of the singleton at the same time, which would violate the singleton pattern.
---10 chapter2
Q: What is the result of the following code?
1:  public interface CanWalk {
2:      default void walk() { System.out.println("Walking"); }
3:  }
4:  public interface CanRun {
5:      public default void walk() { System.out.println("Walking"); }
6:      public abstract void run();
7:  }
8:  public interface CanSprint extends CanWalk, CanRun {
9:      void sprint();
10: }
A.- The code compiles without issue.
B.- The code will not compile because of line 5.
C.- The code will not compile because of line 6.
D.+ The code will not compile because of line 8.
E.- The code will not compile because of line 9.
Y: D.While Java supports multiple inheritance through interfaces,it does not support method overriding in interfaces, since it’s not clear which parent method should be used. In this example, CanWalk and CanRun both implement a default walk() method. The definition of CanSprint extends these two interfaces and therefore won’t compile as two default meth- ods with the same signature from parent classes are detected, therefore the answer is D. None of the other lines of code cause problems, so the rest of the answers are not correct.
---11 chapter2
Q: Which lambda can replace the MySecret class to return the same value? (Choose all that apply.)
1:  public interface Secret {
2:      String magic(double d);
3:  }
4:  public class MySecret implements Secret {
5:      public String magic(double d) {
6:      return "Poof";
7:      }
8:  }
A.+ caller((e) -> "Poof");
B.- caller((e) -> {"Poof"});
C.- caller((e) -> { String e = ""; "Poof" });
D.- caller((e) -> { String e = ""; return "Poof"; });
E.- caller((e) -> { String e = ""; return "Poof" });
F.+ caller((e) -> { String f = ""; return "Poof"; });
Y: A, F. B is incorrect because it does not use the return keyword. C, D, and E are incorrect because the variable e is already in use from the lambda and cannot be redefined. Addition- ally, C is missing the return keyword and E is missing the semicolon. A and F are the only correct lambda expressions that match the functional interface.
---12 chapter2
Q: What is the result of the following code?
1:   public interface Climb {
2:     boolean isTooHigh(int height, int limit);
3:   }
4:   public class Climber {
5:     public static void main(String[] args) {
6:          check((h, l) -> h.toString(), 5); // x1
7:     }
8:     private static void check(Climb climb, int height) {
9:         if (climb.isTooHigh(height, 10)) // x2 System.out.println("too high");
10:        else System.out.println("ok");
11:    }
12: }
A.- ok
B.- too high
C.+ Compiler error on line x1.
D.- Compiler error on line x2.
E.- Compiler error on a different line.
F.- A runtime exception is thrown.
Y: C. The functional interface takes two int parameters. The code on line x1 attempts to use them as if one is an Object, resulting in a compiler error making C the correct answer. It also tries to return String even though the data type for the functional interface method is boolean. It is tricky to use types in a lambda when they are implicitly specified. Remember to check the interface for the real type.
---13 chapter2
Q: Which of the following are properties of classes that define immutable objects? (Choose all that apply.)
A.- They don’t define any getter methods.
B.+ All of the instance variables marked private and final.
C.+ They don’t define any setter methods.
D.- They mark all instance variables static.
E.+ They prevent methods from being overridden.
F.- All getter methods are marked synchronized.
Y: B, C, E. Immutable objects may not be modified after creation. B, C, and E are correct statements that support this property. A is incorrect, as immutable objects may have get- ter methods, just not setter methods. D is incorrect, as static methods are not part of the immutable object pattern. F is also incorrect, as the getter methods are not required to be marked synchronized.
---14 chapter2
Q: Which of the following statements can be inserted in the blank line so that the code will compile successfully? (Choose all that apply.)
1:  public interface CanHop {}
2:  public class Frog implements CanHop {
3:      public static void main(String[] args) {
4:          _______________ frog = new TurtleFrog();
5:      }
6:  }
7:  public class BrazilianHornedFrog extends Frog {}
8:  public class TurtleFrog extends Frog {}
A.+ Frog
B.+ TurtleFrog
C.- BrazilianHornedFrog
D.+ CanHop
E.+ Object
F.- Long
Y: A, B, D, E. The blank can be filled with any class or interface that is a supertype of Tur- tleFrog. A is a superclass of TurtleFrog, and B is the same class, so both are correct. BrazilianHornedFrog is not a superclass of TurtleFrog, so C is incorrect. TurtleFrog inherits the CanHop interface, so D is correct. All classes inherit Object, so E is correct. Finally, Long is an unrelated class that is not a superclass of TurtleFrog, and it is therefore incorrect.
---15 chapter2
Q: Which of the following statements about polymorphism are true? (Choose all that apply.)
A.- A reference to an object may be cast to a subclass of the object without an explicit cast.
B.+ If a method takes a class that is the superclass of three different object references, then any of those objects may be passed as a parameter to the method.
C.+ A reference to an object may be cast to a superclass of the object without an explicit cast.
D.- All cast exceptions can be detected at compile time.
E.- By defining a public instance method in the superclass, you guarantee that the specific method will be called in the parent class at runtime.
Y: B, C. A reference to an object requires an explicit cast if referenced with a subclass, so A is incorrect. If the cast is to a superclass reference, then an explicit cast is not required, so C is correct. If a method takes the superclass of an object as a parameter, then any subclass ref- erences may be used without a cast, so B is correct. Some cast exceptions can be detected as errors at compile-time, but others can only be detected at runtime, so D is incorrect. Due to the nature of polymorphism, a public instance method can be overridden in a subclass and calls to it will be replaced even in the superclass in which it was defined, so E is incorrect.
---16 chapter2
Q: Choose the correct statement about the following code:
1:  public interface Herbivore {
2:      int amount = 10;
3:      public static void eatGrass();
4:      public int chew() {
5:          return 13;
6:      }
7:  }
A.- It compiles and runs without issue.
B.- The code will not compile because of line 2.
C.- The code will not compile because of line 3.
D.- The code will not compile because of line 4.
E.- The code will not compile because of lines 2 and 3.
F.+ The code will not compile because of lines 3 and 4.
Y: F. The interface variable amount is correctly declared, with public, static, and final being assumed and automatically inserted by the compiler, so B is incorrect. The method declaration for eatGrass() on line 3 is incorrect because the method has been marked as static but no method body has been provided. The method declaration for chew() on line 4 is also incorrect, since an interface method that provides a body must be marked as default or static explicitly. Therefore, F is the correct answer since this code contains two compile-time errors.
---17 chapter2
Q: Which of the following are properties of classes that are properly encapsulated as a JavaBean? (Choose all that apply.)
A.- All instance variables are marked final.
B.+ boolean instance variables are accessed with is or get.
C.+ All instance variables are marked private.
D.- They implement the JavaBean interface.
E.- Variables are created using lazy instantiation.
F.+ The first letter of the any getter/setter, after the get, set, or is prefix, must be uppercase.
Y: B, C, F. Options B, C, and F are each correct statements about JavaBean encapsulation. A is incorrect, as that is a property of the immutable object pattern, not encapsulation. D is incorrect, as there is no such JavaBean interface defined in the Java API. Finally, E is incorrect, as handling instantiation is not part of encapsulation.
---18 chapter2
Q: Which of the following statements about inheritance and object composition are correct? (Choose all that apply.)
A.+ Inheritance supports access to protected variables.
B.+ Object composition tends to promote greater code reuse than inheritance.
C.- Inheritance relies on the has‐a principle.
D.- Object composition supports method overriding at runtime.
E.+ Object composition requires a class variable to be declared public or accessible from a public method to be used by a class in a different package.
F.- Object composition is always preferred to inheritance.
Y: A, B, E. A is correct, and it is one of the reasons to prefer class inheritance over object composition. B is also correct, since object composition tends to lead to classes that are easier to reference, as they don’t require knowledge of any parent classes. C is incorrect, as inheritance tends to use the is-a principle, whereas object composition relies on the has-a principle. D is incorrect, as this is a statement about inheritance, not object composition. E is correct, as object composition has no notion of inheritance and variables must be exposed publically if they are to be used by other classes in different packages. F is incor- rect, as neither are always the right answer. There are situations where inheritance is more appropriate, and situations where object composition is more appropriate.
---19 chapter2
Q: Which three scenarios would best benefit from using a singleton pattern? (Choose all three.)
A.- Create read‐only objects that are thread‐safe.
B.+ Manage a reusable cache of objects.
C.- Ensure that all objects are lazily instantiated.
D.+ Manage write access to a log file.
E.+ Provide central access to application configuration data.
F.- Allow multiple instances of a static object to be managed in memory.
Y: B, D, E. A is incorrect, as that is a property of the immutable object pattern. B is correct, as caching data is one of the most common uses of the singleton pattern. While the singleton pattern may use lazy instantiation, it is not used to ensure that objects are lazily instanti- ated, so C is incorrect. D is correct, as we only want one class writing to a log file at once. E is also correct, as managing application-wide configuration data is another very common use of the singleton pattern. F is incorrect, as we only want one instance of a static object created when using the singleton pattern.
---20 chapter2
Q: Choose the correct statement about the following code:
1:  public interface CanFly {
2:      void fly();
3:  }
4:  interface HasWings {
5:      public abstract Object getWingSpan();
6:  }
7:  abstract class Falcon implements CanFly, HasWings {
8:  }
A.+ It compiles without issue.
B.- The code will not compile because of line 2.
C.- The code will not compile because of line 4.
D.- The code will not compile because of line 5.
E.- The code will not compile because of lines 2 and 5.
F.- The code will not compile because the class Falcon doesn’t implement the interface methods.
Y: A. Although the definition of methods on lines 2 and 5 vary, both will be converted to public abstract by the compiler. Line 4 is fine, because an interface can have public or default access. Finally, the class Falcon doesn’t need to implement the interface methods because it is marked as abstract. Therefore, the code will compile without issue.
---1 chapter3
Q: Suppose that you have a collection of products for sale in a database and you need to display those products. The products are not unique. Which of the following collections classes in the java.util package best suit your needs for this scenario?
A.- Arrays
B.+ ArrayList
C.- HashMap
D.- HashSet
E.- LinkedList
Y: B. The answer needs to implement List because the scenario allows duplicates. Since you need a List, you can eliminate C, D, and E immediately. HashMap is a Map and HashSet is a Set. LinkedList is both a List and a Queue. You want a regular List. Option A, Arrays, is trying to distract you. It is a utility class rather than a Collection. An array is not a col- lection. By process of elimination, the answer is B.
---2 chapter3
Q: Suppose that you need to work with a collection of elements that need to be sorted in their natural order, and each element has a unique string associated with its value. Which of the following collections classes in the java.util package best suit your needs for this scenario?
A.- ArrayList
B.- HashMap
C.- HashSet
D.+ TreeMap
E.- TreeSet
F.- Vector
Y: D. The answer needs to implement Map because you are dealing with key/value pairs per the unique string text. You can eliminate A, C, E, and F immediately. ArrayList and Vector are Lists. HashSet and TreeSet are Sets. Now it is between HashMap and TreeMap. Since the question talks about ordering, you need the TreeMap. Therefore, the answer is E.
---3 chapter3
Q: What is the result of the following statements?
3: List list = new ArrayList();
4: list.add("one");
5: list.add("two");
6: list.add(7);
7: for (String s: list)
8: System.out.print(s);
A.- onetwo
B.- onetwo7
C.- onetwo followed by an exception
D.- Compiler error on line 6
E.+ Compiler error on line 7
Y: E. The code does not compile. It attempts to mix generics and legacy code. Lines 3 through 7 create an ArrayList without generics. This means that we can put any objects in it. Line 7 should be looping through a list of Objects rather than Strings since we didn’t use generics.
---4 chapter3
Q: What is the result of the following statements?
3: ArrayDeque<String> greetings = new ArrayDeque<String>();
4: greetings.push("hello");
5: greetings.push("hi");
6: greetings.push("ola");
7: greetings.pop();
8: greetings.peek();
9: while (greetings.peek() != null)
10:      System.out.print(greetings.pop());
A.- hello
B.- hellohi
C.- hellohiola
D.- hi
E.+ hihello
F.- The code does not compile.
F.- An exception is thrown.
Y: E. Since we call push() rather than offer(), we are treating the ArrayDeque as a LIFO (last-in, first-out) stack. On line 7, we remove the last element added, which is "ola". On line 8, we look at the new last element ("hi"), but don’t remove it. Lines 9 and 10, we remove each element in turn until none are left. Note that we don’t use an Iterator to loop through the ArrayDeque. The order in which the elements are stored internally is not part of the API contract.
---5 chapter3
Q: Which of these statements compile? (Choose all that apply.)
A.- HashSet<Number> hs = new HashSet<Integer>();
B.+ HashSet<? super ClassCastException> set = new HashSet<Exception>();
C.+ List<String> list = new Vector<String>();
D.- List<Object> values = new HashSet<Object>();
E.- List<Object> objects = new ArrayList<? extends Object>();
F.+ Map<String, ? extends Number> hm = new HashMap<String, Integer>();
Y: B, C, F. Option A does not compile because the generic types are not compatible. We could say HashSet<? extends Number> hs2 = new HashSet<Integer>();. Option B uses a lower bound, so it allows superclass generic types. Option C is a traditional use of generics where the generic type is the same and the List type uses the interface as the type. Option D does not compile because a Set is not a List. Option E does not compile because upper bounds are not allowed when instantiating the type. Finally, Option F does compile because the upper bound is on the correct side of =.
---6 chapter3
Q: What is the result of the following code?
1:  public class Hello<T> {
2:      T t;
3:      public Hello(T t) { this.t = t; }
4:      public String toString() { return t.toString(); }
5:      public static void main(String[] args) {
6:          System.out.print(new Hello<String>("hi"));
7:          System.out.print(new Hello("there"));
8:  }}
A.- hi
B.- hi followed by a runtime exception
C.+ hithere
D.- Compiler error on line 4
E.- Compiler error on line 6
F.- Compiler error on line 7
Y: C. Line 7 gives a compiler warning for not using generics but not a compiler error. Line 4 compiles fine because toString() is defined on the Object class and is therefore always available to call. Line 6 creates the Hello class with the generic type String. Line 7 creates the Hello class with the generic type Object since no type is specified.
---7 chapter3
Q: Which of the following statements are true? (Select two.)
3:  Set<Number> numbers = new HashSet<>();
4:  numbers.add(new Integer(86));
5:  numbers.add(75);
6:  numbers.add(new Integer(86));
7:  numbers.add(null);
8:  numbers.add(309L);
9:  Iterator iter = numbers.iterator();
10: while (iter.hasNext())
11:     System.out.print(iter.next());
A.+ The code compiles successfully.
B.- The output is 8675null309.
C.- The output is 867586null309.
D.+ The output is indeterminate.
E.- There is a compiler error on line 3.
F.- There is a compiler error on line 9.
G.- An exception is thrown.
Y: A, D. The code compiles fine. It uses the diamond operator, and it allows any implementation of Number to be added. HashSet does not guarantee any iteration order, making A and D correct.
---8 chapter3
Q: What is the result of the following code?
1: TreeSet<String> tree = new TreeSet<String>();
2: tree.add("one");
3: tree.add("One");
4: tree.add("ONE");
5: System.out.println(tree.ceiling("On"));
A.- On
B.- one
C.+ One
D.- ONE
E.- The code does not compile.
F.- An exception is thrown.
Y: C. TreeSet sorts the elements. Since uppercase letters sort before lowercase letters, the ordering is "ONE", "One", "one". The ceiling() method returns the smallest element greater than the specified one. "On" appears between "ONE" and "One". Therefore, the smallest element that is larger than the specified value is "One".
---9 chapter3
Q: Which of the answer choices are valid given the following declaration?
1: Map<String, Double> map = new HashMap<>();
A.- map.add("pi", 3.14159);
B.- map.add("e", 2L);
C.- map.add("log(1)", new Double(0.0));
D.- map.add('x', new Double(123.4));
E.+ None of the above
Y: E. Trick question! The Map interface uses put() rather than add() to add elements to the map. If these examples used put(), the answer would be A and C. B is no good because a long cannot be shoved into a Double. D is no good because a char is not the same thing as a String.
---10 chapter3
Q: What is the result of the following program?
1: import java.util.*;
2: public class MyComparator implements Comparator<String> {
3:   public int compare(String a, String b) {
4:      return b.toLowerCase().compareTo(a.toLowerCase());
5:   }
6:   public static void main(String[] args) {
7:      String[] values = { "123", "Abb", "aab" };
8:      Arrays.sort(values, new MyComparator());
9:      for (String s: values)
10:          System.out.print(s + " ");
11:  }
12: }
A.+ Abb aab 123
B.- aab Abb 123
C.- 123 Abb aab
D.- 123 aab Abb
E.- The code does not compile.
F.- A runtime exception is thrown.
Y: A. The array is sorted using MyComparator, which sorts the elements in reverse alphabeti- cal order in a case-insensitive fashion. Normally, numbers sort before letters. This code reverses that by calling the compareTo() method on b instead of a.
---11 chapter3
Q: What is the result of the following code?
3: Map<Integer, Integer> map = new HashMap<>(10);
4: for (int i = 1; i <= 10; i++) {
5:      map.put(i, i * i);
6: }
7: System.out.println(map.get(4));
A.+ 16
B.- 25
C.- Compiler error on line 3.
D.- Compiler error on line 5.
E.- Compiler error on line 7.
F.- A runtime exception is thrown.
Y: A. Line 3 uses the diamond operator to create the map. Lines 5 and 7 use autoboxing to convert between the int primitive and the Integer wrapper class. The keys map to their squared value. 1 maps to 1, 2 maps to 4, 3 maps to 9, 4 maps to 16, and so on.
---12 chapter3
Q: Which of these statements can fill in the blank so that the Helper class compiles successfully? (Choose all that apply.)
3:  public class Helper {
4:      public static <U extends Exception> void printException(U u) {
5:          System.out.println(u.getMessage());
6:      }
7:  public static void main(String[] args) {
8:      __________________________________
9:  } }
A.+ Helper.printException(new FileNotFoundException("A"));
B.+ Helper.printException(new Exception("B"));
C.- Helper.<Throwable>printException(new Exception("C"));
D.+ Helper.<NullPointerException>printException(new NullPointerException ("D"));
E.- Helper.printException(new Throwable("E"));
Y: A, B, D. The generic type must be Exception or a subclass of Exception since this is an upper bound. C and E are wrong because Throwable is a superclass of Exception. D uses an odd syntax by explicitly listing the type, but you should be able to recognize it as acceptable.
---13 chapter3
Q: Which of these statements can fill in the blank so that the Wildcard class compiles successfully? (Choose all that apply.)
1:   import java.util.*;
2:   public class Wildcard {
3:     public void showSize(List<?> list) {
4:         System.out.println(list.size());
5:     }
6:   public static void main(String[] args) {
7:      Wildcard card = new Wildcard();
8:      ____________________________________
9:      card.showSize(list);
10:   }}
A.- ArrayDeque<?> list = new ArrayDeque<String>();
B.+ ArrayList<? super Date> list = new ArrayList<Date>();
C.- List<?> list = new ArrayList<?>();
D.- List<Exception> list = new LinkedList<java.io.IOException>();
E.+ Vector<? extends Number> list = new Vector<Integer>();
F.- None of the above
Y: B, E. showSize() can take any type of List since it uses an unbounded wildcard. Option A is incorrect because it is a Queue and not a List. Option C is incorrect because the wild- card is not allowed to be on the right side of an assignment. Option D is incorrect because the generic types are not compatible. Option B is correct because a lower-bounded wildcard allows that same type to be the generic. Option E is correct because Integer is a subclass of Number. Vector is an old type of List. It isn’t common in new code, but you still need to know it for the exam and in case you encounter old code.
---14 chapter3
Q: What is the result of the following program?
1:   import java.util.*;
2:   public class Sorted implements Comparable<Sorted>, Comparator<Sorted> {
3:     private int num;
4:     private String text;
5:     Sorted(int n, String t) {
6:          this.num = n;
7:          this.text = t;
8:     }
9:     public String toString() {
10:      return "" + num;
11:    }
12:    public int compareTo(Sorted s) {
13:      return text.compareTo(s.text);
14:    }
15:    public int compare(Sorted s1, Sorted s2) {
16:      return s1.num – s2.num;
17:    }
18:    public static void main(String[] args) {
19:      Sorted s1 = new Sorted(88, "a");
20:      Sorted s2 = new Sorted(55, "b");
21:      TreeSet<Sorted> t1 = new TreeSet<>();
22:      t1.add(s1);
23:      t1.add(s2);
24:      TreeSet<Sorted> t2 = new TreeSet<>(s1);
25:      t2.add(s1);
26:      t2.add(s2);
27:      System.out.println(t1 + " " + t2);
28:   }}
A.- [55. 88] [55, 88]
B.- [55. 88] [88, 55]
C.+ [88. 55] [55, 88]
D.- [88. 55] [88, 55]
E.- The code does not compile.
F.- A runtime exception is thrown.
Y: C. This question is hard because it defines both Comparable and Comparator on the same object. t1 doesn’t specify a Comparator so it uses the Comparable object’s compareTo() method. This sorts by the text instance variable. t2 did specify a Comparator when calling the constructor, so it uses the compare() method, which sorts by the int.
---15 chapter3
Q: What is the result of the following code?
1:  Comparator<Integer> c = (o1, o2) -> o2—o1;
2:  List<Integer> list = Arrays.asList(5, 4, 7, 1);
3:  Collections.sort(list, c);
4:  System.out.println(Collections.binarySearch(list, 1));
A.- 0
B.- 1
C.- 2
D.+ The result is undefined.
E.- The code does not compile.
F.- A runtime exception is thrown.
Y: D. The list is sorted in descending order. However, it is searched using the default order, which is sorted in ascending order. binarySearch() requires both to use the same sort order. Therefore, the precondition for binarySearch() is not met and the result is undefined.
---16 chapter3
Q: Which of the following statements are true? (Choose all that apply.)
A.- Comparable is in the java.util package.
B.+ Comparator is in the java.util package.
C.- compare() is in the Comparable interface.
D.+ compare() is in the Comparator interface.
E.- compare() takes one method parameter.
F.+ compare() takes two method parameters.
Y: B, D, F. The java.lang.Comparable interface is implemented on the object to com- pare. It specifies the compareTo() method, which takes one parameter. The java. util.Comparator interface specifies the compare() method, which takes two parameters.
---17 chapter3
Q: Which two options can fill in the blanks to make this code compile? (Choose all that apply.)
1:  public class Generic________ {
2:      public static void main(String[] args) {
3:          Generic<String> g = new Generic_______();
4:          Generic<Object> g2 = new Generic();
5:      }
6:  }
A.- On line 1 fill in with <>.
B.+ On line 1, fill in with <T>.
C.- On line 1, fill in with <?>.
D.+ On line 3, fill in with <>.
E.- On line 3, fill in with <T>.
F.- On line 3, fill in with <?>.
Y: B, D. Line 1 is a generic class that requires specifying a name for the type. Options A and C are incorrect because no type is specified. Line 3 tries to use the diamond operator to instantiate the class. Option E is incorrect because T is not a class and certainly not one compatible with String. Option F is incorrect because a wildcard cannot be specified on the right side when instantiating an object.
---18 chapter3
Q: Which of the following lines can be inserted to make the code compile?(Choose all that apply.)
1:  class A {}
2:  class B extends A {}
3:  class C extends B {}
4:  class D<C> {
5:      // INSERT CODE HERE
6:  }
A.+ A a1 = new A();
B.+ A a2 = new B();
C.+ A a3 = new C();
D.- C c1 = new A();
E.- C c2 = new B();
F.- C c1 = new C();
Y: A, B. C is both a class and a type parameter. This means that within the class D, when we refer to C, it uses the type parameter. All of the choices that mention class C are incorrect because it no longer means the class C.
---19 chapter3
Q: Which options are true of the following code? (Choose all that apply.)
3: ______________<Integer> q = new LinkedList<>();
4: q.add(10);
5: q.add(12);
6: q.remove(1);
7: System.out.print(q);
A.+ If we fill in the blank with List, the output is [10].
B.- If we fill in the blank with List, the output is [10, 12].
C.- If we fill in the blank with Queue, the output is [10].
D.+ If we fill in the blank with Queue, the output is [10, 12].
E.- The code does not compile in either scenario.
F.- A runtime exception is thrown.
Y: A, D. A LinkedList implements both List and Queue. The List interface has a method to remove by index. Since this method exists, Java does not autobox to call the other method. Queue has only the remove by object method, so Java does autobox there. Since the number 1 is not in the list, Java does not remove anything for the Queue.
---20 chapter3
Q: What is the result of the following code?
4: Map m = new HashMap();
5: m.put(123, "456");
6: m.put("abc", "def");
7: System.out.println(m.contains("123"));
A.- false
B.- true
C.- Compiler error on line 4.
D.- Compiler error on line 5.
E.+ Compiler error on line 7.
F.- A runtime exception is thrown.
Y: E. This question looks like it is about generics, but it’s not. It is trying to see if you noticed that Map does not have a contains() method. It has containsKey() and containsValue() instead. If containsKey() was called, the answer would be false because the 123 in the list is an Integer rather than a String.
---21 chapter3
Q: Fill in the blanks to make this code compile and print 123. (Choose all that apply.)
4: List<String> list = Arrays.asList("1", "2", "3");
5: Iterator iter = list.iterator();
6: while(iter.__________())
7:   System.out.print(iter._________());
A.+ On line 6, fill in the blank with hasNext().
B.- On line 6, fill in the blank with isNext().
C.- On line 6, fill in the blank with next().
D.- On line 7, fill in the blank with getNext().
E.- On line 7, fill in the blank with hasNext().
F.+ On line 7, fill in the blank with next().
Y: A, F. You have to memorize this. hasNext() returns a boolean, and it is used in the loop. next() returns the next element.
---22 chapter3
Q: What code change is needed to make the method compile?
1:  public static T identity(T t) {
2:      return t;
3:  }
A.- Add <T> after the public keyword.
B.+ Add <T> after the static keyword.
C.- Add <T> after T.
D.- Add <?> after the public keyword.
E.- Add <?> after the static keyword.
F.- No change required. The code already compiles.
Y: B. When using generic types in a static method, the generic specification goes before the return type.
---23 chapter3
Q: Which of the answer choices make sense to implement with a lambda?(Choose all that apply.)
A.- Comparable interface
B.+ Comparator interface
C.- remove method on a Collection
D.- removeAll method on a Collection
E.+ removeIf method on a Collection
Y: B, E. Both Comparator and Comparable are functional interfaces. However, Comparable is intended to be used on the object being compared, making choice B correct. removeIf was added in Java 8 to allow specifying the lambda to check when removing elements, making choice E correct.
---24 chapter3
Q: Which of the following compiles and print outs the entire set? (Choose all that apply.)
1: Set<String> s = new HashSet<>();
2: s.add("lion");
3: s.add("tiger");
4: s.add("bear");
5: s.forEach(   );
A.- () -> System.out.println(s)
B.- s -> System.out.println(s)
C.- (s) -> System.out.println(s)
D.- System.out.println(s)
E.- System::out::println
F.+ System.out::println
Y: F. Choice A is incorrect because forEach takes a Consumer parameter, which requires one parameter. Choices B and C are close. The syntax for a lambda is correct. However, s is already defined as a local variable and therefore the lambda can’t redefine it. Choices D and E use incorrect syntax for a method reference. Choice F is correct.
---25 chapter3
Q: What is the result of the following?
1: Map<Integer, Integer> map = new HashMap<>();
2: map.put(1, 10);
3: map.put(2, 20);
4: map.put(3, null);
5: map.merge(1, 3, (a,b) -> a + b);
6: map.merge(3, 3, (a,b) -> a + b);
7: System.out.println(map);
A.- {1=10, 2=20}
B.- {1=10, 2=20, 3=null}
C.- {1=10, 2=20, 3=3}
D.- {1=13, 2=20}
E.- {1=13, 2=20, 3=null}
F.+ {1=13, 2=20, 3=3}
G.- The code does not compile.
H.- An exception is thrown.
Y: F. The first call to merge() calls the mapping function and adds the two numbers to get 13. It then updates the map. The second call to merge() sees that the map currently has a null value for that key. It does not call the mapping function but instead replaces it with the new value of 3. Therefore choice F is correct.
---1 chapter4
Q: What is the output of the following?
1:  Stream<String> stream = Stream.iterate("", (s) -> s + "1");
2:  System.out.println(stream.limit(2).map(x -> x + "2"));
A.- 12112
B.- 212
C.- 212112
D.+ java.util.stream.ReferencePipeline$3@4517d9a3
E.- The code does not compile.
F.- An exception is thrown.
G.- The code hangs.
Y: D. No terminal operation is called, so the stream never executes. The methods chain to create a stream that would contain “2” and “12.” The first line creates an infinite stream. The second line would get the first two elements from that infinite stream and map each element to add an extra character.
---2 chapter4
Q: What is the output of the following?
1:   Predicate<? super String> predicate = s -> s.startsWith("g");
2:   Stream<String> stream1 = Stream.generate(() -> "growl! ");
3:   Stream<String> stream2 = Stream.generate(() -> "growl! ");
4:   boolean b1 = stream1.anyMatch(predicate);
5:   boolean b2 = stream2.allMatch(predicate);
6:   System.out.println(b1 + " " + b2);
A.- true false
B.- true true
C.- java.util.stream.ReferencePipeline$3@4517d9a3
D.- The code does not compile.
E.- An exception is thrown.
F.+ The code hangs.
Y: F. b1 is set to true since anyMatch() terminates. Even though the stream is infinite, Java finds a match on the first element and stops looking. However, when allMatch() runs, it needs to keep going until the end of the stream since it keeps finding matches. Since all elements continue to match, the program hangs.
---3 chapter4
Q: What is the output of the following?
1:   Predicate<? super String> predicate = s -> s.length() > 3;
2:   Stream<String> stream = Stream.iterate("-", (s) -> s + s);
3:   boolean b1 = stream.noneMatch(predicate);
4:   boolean b2 = stream.anyMatch(predicate);
5:   System.out.println(b1 + " " + b2);
A.- false true
B.- false false
C.- java.util.stream.ReferencePipeline$3@4517d9a3
D.- The code does not compile.
E.+ An exception is thrown.
F.- The code hangs.
Y: E. An infinite stream is generated where each element is twice as long as the previous one. b1 is set to false because Java finds an element that doesn’t match when it gets to the element of length 4. However, the next line tries to operate on the same stream. Since streams can be used only once, this throws an exception that the “stream has already been operated upon or closed.” If two different streams were used, the result would be option A.
---4 chapter4
Q: Which are true statements about terminal operations in a stream? (Choose all that apply.)
A.+ At most one terminal operation can exist in a stream pipeline.
B.+ Terminal operations are a required part of the stream pipeline in order to get a result.
C.- Terminal operations have Stream as the return type.
D.- The referenced Stream may be used after the calling a terminal operation.
E.- The peek() method is an example of a terminal operation.
Y: A, B. Terminal operations are the final step in a stream pipeline. Exactly one is required, because it triggers the execution of the entire stream pipeline. Therefore, options A and B are correct. Options C and F are true of intermediate operations rather than terminal operations. Option E is never true. Once a stream pipeline is run, the Stream is marked invalid.
---5 chapter4
Q: Which terminal operations on the Stream class are reductions? (Choose all that apply.)
A.+ collect()
B.+ count()
C.- findFirst()
D.- map()
E.- peek()
F.- sum()
Y: A, B. Options D and E are incorrect because they are intermediate operations and not terminal operations. While option F is a reduction, it is incorrect because it is available only on primitive streams such as IntStream. Option C is incorrect because it is not a reduction it does not look at each element in the stream.
---6 chapter4
Q: Which of the following can fill in the blank so that the code prints out false? (Choose all that apply.)
1:   Stream<String> s = Stream.generate(() -> "meow");
2:   boolean match = s.________________(String::isEmpty);
3:   System.out.println(match);
A.+ allMatch
B.- anyMatch
C.- findAny
D.- findFirst
E.- noneMatch
F.- None of the above
Y: A. Options C and D are incorrect because these methods do not take a Predicate parameter and do not return a boolean. Options B and E are incorrect because they cause the code to run infinitely. The stream has no way to know that a match won’t show up later. Option A is correct because it is safe to return false as soon as one element passes through the stream that doesn’t match.
---7 chapter4
Q: We have a method that returns a sorted list without changing the original. Which of the following can replace the method implementation to do the same with streams?
1:   private static List<String> sort(List<String> list) {
2:        List<String> copy = new ArrayList<>(list);
3:        Collections.sort(copy, (a, b) -> b.compareTo(a));
4:        return copy;
5:   }
A.- return list.stream().compare((a, b) -> b.compareTo(a)) .collect(Collectors.toList());
B.- return list.stream().compare((a, b) -> b.compareTo(a)) .sort();
C.- return list.stream().compareTo((a, b) -> b.compareTo(a)) .collect(Collectors.toList());
D.- return list.stream().compareTo((a, b) -> b.compareTo(a)) .sort();
E.- return list.stream().sorted((a, b) -> b.compareTo(a)) .collect();
F.+ return list.stream().sorted((a, b) -> b.compareTo(a)) .collect(Collectors.toList());
Y: F. The sorted() method is used in a stream pipeline to return a sorted Stream. A collector is needed to turn the stream back into a List. The collect() method takes the desired collector.
---8 chapter4
Q: Which of the following are true given the declaration IntStream is = IntStream. empty()? (Choose all that apply.)
A.- is.average() returns the type int.
B.- is.average() returns the type OptionalInt.
C.- is.findAny() returns the type int.
D.+ is.findAny() returns the type OptionalInt.
E.+ is.sum() returns the type int.
F.- is.sum() returns the type OptionalInt.
Y: D, E. The sum() method returns an int rather than an OptionalInt because the sum of an empty list is zero. Therefore, option E is correct. The findAny() method returns an OptionalInt because there might not be any elements to find. Therefore, option D is correct. The average() method returns an OptionalDouble since averages of any type can result in a fraction. Therefore, options A and B are both incorrect.
---9 chapter4
Q: Which of the following can we add after line 5 for the code to run without error and not produce any output? (Choose all that apply.)
4: LongStream ls = LongStream.of(1, 2, 3);
5: OptionalLong opt = ls.map(n -> n * 10).filter(n -> n < 5).findFirst();
A.- if (opt.isPresent()) System.out.println(opt.get());
B.+ if (opt.isPresent()) System.out.println(opt.getAsLong());
C.- opt.ifPresent(System.out.println)
D.+ opt.ifPresent(System.out::println)
E.- None of these; the code does not compile.
F.- None of these; line 5 throws an exception at runtime.
Y: B, D. Option A would work for a regular Stream. However, we have a LongStream and therefore need to call getAsLong(). Option C is missing the :: that would make it a method reference. Therefore, options B and D are correct.
---10 chapter4
Q: Select from the following statements and indicate the order in which they would appear to output 10 lines:
1:  Stream.generate(() -> "1")
2:  L: .filter(x -> x.length() > 1)
3:  M: .forEach(System.out::println)
4:  N: .limit(10)
5:  O: .peek(System.out::println);
A.- L, N
B.- L, N, O
C.- L, N, M
D.- L, N, M, O
E.- L, O, M
F.+ N, M
G.- N, O
Y: F. The terminal operation must be right before the semicolon, which is line M. Remember that forEach() is a terminal operation while peek() is an intermediate operation. This eliminates all but choices C, E, and F. Choice E is incorrect because there is no limit() operation, which means that the code would run infinitely. Choice C is incorrect because filter() is called before limit(). No elements make it through the filter, so the code also runs infinitely. Choice F is correct.
---11 chapter4
Q: What changes need to be made for this code to print the string 12345? (Choose all that apply.)
1:   Stream.iterate(1, x -> x++)
2:         .limit(5)
3:         .map(x -> x)
4:         .collect(Collectors. joining());
A.- Change Collectors.joining() to Collectors.joining("").
B.+ Change map(x -> x)to map(x -> "" + x).
C.+ Change x -> x++ to x -> ++x.
D.- Add forEach(System.out::print) after the call to collect().
E.+ Wrap the entire line in a System.out.print statement.
F.- None of the above. The code already prints 12345.
Y: B, C, E. As written, the code doesn’t compile because the collector expects to get a String immediately before it in the chain. Option B fixes this, at which point nothing is output because the collector creates a String. Option E fixes this and causes the output to be 11111. Since the post-increment operator is used, the stream contains an infinite number of 1s. Option C fixes this and causes the stream to contain increasing numbers.
---12 chapter4
Q: Which functional interfaces complete the following code? (Choose all that apply.)
6: ____________ x = String::new;
7: ____________ y = (a, b) -> System.out.println();
8: ____________ z = a -> a + a;
A.+ BiConsumer<String, String>
B.- BiFunction<String, String>
C.- BinaryConsumer<String, String>
D.- BinaryFunction<String, String>
E.- Consumer<String>
F.+ Supplier<String>
G.+ UnaryOperator<String>
H.- UnaryOperator<String, String>
Y: A, F, G. Line 6 doesn’t take any parameters, and it returns a String, making it a Supplier. Another clue is that it uses a constructor reference, which should scream Supplier! This makes choice F correct. Line 7 takes two parameters, and it doesn’t return anything making it a BiConsumer. The print statement should also be a clue that we are dealing with a Consumer or BiConsumer. This makes choice A correct. Choices C and D are there to mislead you; these interfaces don’t actually exist. BinaryOperator spells out binary. The other functional interfaces use the prefix Bi. Finally, line 8 takes a single parameter, and it returns the same type, which is a UnaryOperator. Since the types are the same, only one generic is needed, making choice G correct.
---13 chapter4
Q: Which of the following is true?
1:  List<Integer> l1 = Arrays.asList(1, 2, 3);
2:  List<Integer> l2 = Arrays.asList(4, 5, 6);
3:  List<Integer> l3 = Arrays.asList();
4:  Stream.of(l1, l2, l3)
5:        .map(x -> x + 1)
6:        .flatMap(x -> x.stream())
7:        .forEach(System.out::print);
A.- The code compiles and prints 123456.
B.- The code compiles and prints 234567.
C.- The code compiles but does not print anything.
D.- The code compiles but prints stream references.
E.- The code runs infinitely.
F.+ The code does not compile.
G.- The code throws an exception
Y: F. If the map() and flatMap() calls were reversed, choice B would be correct. In this case, the Stream created from the source is of type Stream<List<Integer>>. The Function in map expects an Integer rather than a List<Integer>, so the code does not compile.
---14 chapter4
Q: Which of the following is true?
4: Stream<Integer> s = Stream.of(1);
5: IntStream is = s.mapToInt(x -> x);
6: DoubleStream ds = s.mapToDouble(x -> x);
7: Stream<Integer> s2 = ds.mapToInt(x -> x);
8: s2.forEach(System.out::print);
A.- Line 4 does not compile.
B.- Line 5 does not compile.
C.- Line 6 does not compile.
D.+ Line 7 does not compile.
E.- Line 8 does not compile.
F.- The code throws an exception.
G.- The code compiles and prints 1.
Y: D. Line 4 should obviously look OK. It creates a Stream and uses autoboxing to put the Integer 1 inside. Line 5 converts to a primitive, again using autoboxing. Line 6 converts to a double primitive, which works since double d = 1; would work. Line 7 is where it all falls apart. Converting from a double to an int would require a cast inside the lambda.
---15 chapter4
Q: The partitioningBy() collector creates a Map<Boolean, List<String>> when passed to collect() by default. When specific parameters are passed to partitioningBy(), which return types can be created? (Choose all that apply.)
A.- Map<boolean, List<String>>
B.- Map<Boolean, Map<String>>
C.- Map<Long, TreeSet<String>>
D.+ Map<Boolean, List<String>>
E.+ Map<Boolean, Set<String>>
F.- None of the above
Y: D, E. Choices A and B do not compile, because they are invalid generic declarations. Primitives are not allowed as generics, and Map must have two generic types. Choice C is incorrect because partitioning only gives a Boolean key. Choices D and E are correct because the result Collection can be customized.
---16 chapter4
Q: What is the output of the following?
1:  Stream<String> s = Stream.empty();
2:  Stream<String> s2 = Stream.empty();
3:  Map<Boolean, List<String>> p = s.collect(
4:     Collectors.partitioningBy(b -> b.startsWith("c")));
5:  Map<Boolean, List<String>> g = s2.collect(
6:     Collectors.groupingBy(b -> b.startsWith("c")));
7:  System.out.println(p + " " + g);
A.- {} {}
B.- {} {false=[], true=[]}
C.+ {false=[], true=[]} {}
D.- {false=[], true=[]} {false=[], true=[]}
E.- The code does not compile.
F.- An exception is thrown.
Y: C. The partitioningBy() operation always returns a map with two Boolean keys, even if there are no corresponding values. By contrast, groupingBy() returns only keys that are actually needed.
---17 chapter4
Q: Which of the following is equivalent to this code? UnaryOperator<Integer> u = x -> x * x;
A.- BiFunction<Integer> f = x -> x*x;
B.- BiFunction<Integer, Integer> f = x -> x*x;
C.- BinaryOperator<Integer, Integer> f = x -> x*x;
D.- Function<Integer> f = x -> x*x;
E.+ Function<Integer, Integer> f = x -> x*x;
F.- None of the above
Y: E. A UnaryOperator is a special type of function where the parameter and return type are the same. Therefore, option E is correct. Notice that other options don’t even compile because they have the wrong number of generic types for the functional interface provided.
---18 chapter4
Q: What is the result of the following?
1:  DoubleStream s = DoubleStream.of(1.2, 2.4);
2:  s.peek(System.out::println)
3:       .filter(x -> x > 2)
4:       .count();
A.- 1
B.- 2
C.- 2.4
D.+ 1.2 and 2.4
E.- There is no output.
F.- The code does not compile.
G.- An exception is thrown.
Y: D. The terminal operation is count(). Since there is a terminal operation, the intermediate operations run. The peek() operation comes before the filter, so both numbers are printed. The count happens to be 1 since the other number is filtered. However, the result of the stream pipeline isn’t stored in a variable, and that result is ignored.
---19 chapter4
Q: Which of the following return primitives? (Choose all that apply.)
A.+ BooleanSupplier
B.- CharSupplier
C.+ DoubleSupplier
D.- FloatSupplier
E.+ IntSupplier
F.- StringSupplier
Y: A, C, E. The three common types of double, int and, long have dedicated supplier classes. The only primitive functional interface that does not involve one of those three types is BooleanSupplier.
---20 chapter4
Q: What is the simplest way of rewriting this code?
1:   List<Integer> l = IntStream.range(1, 6)
2:      .mapToObj(i -> i)
3:      .collect(Collectors.toList());
4:   l.forEach(System.out::println);
A.- IntStream.range(1, 6);
B.+ IntStream.range(1, 6).forEach(System.out::println);
C.- IntStream.range(1, 6).mapToObj(1 -> i).forEach(System.out::println);
D.- None of the above is equivalent.
E.- The provided code does not compile.
Y: B. Both lists and streams have forEach() methods. There is no reason to collect into a list just to loop through it.